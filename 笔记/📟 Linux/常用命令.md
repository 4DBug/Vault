## cd 变更目录

**c**hange **d**irectory，变更目录的含义，使用这个命令可以变更当前 **工作目录** 的位置
示例：

```shell
$ pwd # pwd 可以获取当前工作目录地址
/home/neko

$ cd /etc

$ pwd
/etc # 可以看到这里发生了变更
```

**⚠️ 注意**：`cd` 命令是 shell 程序（诸如 bash、zsh）自己实现的功能，并不是一个实际的可执行程序

## ls 列出文件

**l**i**s**t，列表的含义，使用这个命令可以看到当前 **工作目录** 下的文件
示例：

```shell
$ ls
aria2.sh  btop  ca.crt  go  source
```

### 展示隐藏文件 - 参数 a

通常目录中还会存在一些隐藏文件，比如以英文句点 `.` 开头的文件，这些文件默认是不会被 `ls` 列举出来的，需要添加 **参数 `a`**，`a` 指的是 all（全部）

示例：

```shell
$ ls -a
.   aria2.sh  .bash_logout  .viminfo  .yarn  .z .zshrc.pre-oh-my-zsh
```

### 列表形式打印 - 参数 l

横着打印的话并不是很方便去阅读和理解，我们可以把 `ls` 命令的结果使用列表的形式展示出来，需要添加**参数 `l`**，`l` 指的是 list（列表）

```shell
$ ls -l
总用量 36
-rwxrwxr-x 1 neko neko 29496 6月  15 15:37 aria2.sh
drwxrwxr-x 4 neko neko   188 9月  28 22:35 btop
-rw-r--r-- 1 root root  2163 8月  28 11:34 ca.crt
drwxrwxr-x 4 neko neko    28 7月  30 14:33 go
drwxrwxr-x 3 neko neko    23 9月  29 16:17 source
```

列表中有许多信息，这些信息可以通过下面的列表来一一对应查看：

| 权限 | 链接数 | 归属用户 | 归属用户组 | 大小 | 最后更新月份 | 最后更新日期 | 最后更新时间 | 名称 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | -- |
| -rwxrwxr-x | 1 | neko | neko | 29496 | 6月 | 15 | 15:37 | aria2.sh |
| drwxrwxr-x | 4 | neko | neko | 188  | 9月 | 28 | 22:35 | btop |
| -rw-r--r-- | 1 | root | root | 2163 | 8月 | 28 | 11:34 | ca.crt |
| drwxrwxr-x | 4 | neko | neko | 28 | 7月 | 30 | 14:33 | go |
| drwxrwxr-x | 3 | neko | neko | 23 | 9月 | 29 | 16:17 | source |

关于权限，可以参考：[[权限]]
其中：
1. **链接数** 指的是 Unix 文件系统中的 inode 链接数，这个值只对目录有效，指的是目录下面的 **项目数量**
2. **用户组** 在这个地方通常每个用户会对应有一个同名的组，这个组也有可能是别的组，比如 wheel（RHEL 系 Linux 系统的超级管理员组组名）
3. **最后更新时间** 是根据本机的时区来计算的，如果是通过 SSH 访问的机器，这个时间对应的是服务器的时间，并非是本地计算机的时间

## which/where 获取命令对应的可执行文件

which，哪个，where，在哪里的含义，使用这个命令可以获取到可执行命令的具体位置，这个命令包含以下集中形式：
1. shell 程序定义、内建的可执行命令，比如 cd
2. shell 脚本，可以被 shell 程序读取的代码文件，比如 hello_world.sh、hello_world.zsh 等等
3. 二进制可执行文件，编译好的程序，比如 curl、ls 等等

找不到命令和东西的时候可以先用这个试试看w

示例：
```shell
$ which cd # shell 内建命令
cd: shell built-in command # cd: shell 程序内建的命令

$ which hello_world.sh # sh 脚本文件
/usr/local/bin/hello_world.sh

$ which curl # 二进制可执行文件
/usr/bin/curl
```

## file 获取文件信息

file，文件的含义，使用这个命令可以获取文件的信息、编码、格式、大小等等信息。
示例：

1. 看文本文件

hello 文件里面写着：hello, world!

```shell
$ file hello
hello: ASCII text
```

hello 文件里面写着：世界你好！

```shell
$ file hello
hello: UTF-8 Unicode text
```

2. 看二进制文件

```shell
$ which curl
/usr/bin/curl

$ file /usr/bin/curl
/usr/bin/curl: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=a8c37790f6e986650f939fc4eea9383d527b23fd, stripped
```

可以看到它说 curl 是一个 ELF 64 位 LSB 共享对象，对应平台 x86-64，版本 1（SYSV），通过动态链接库调用内部的运行库，调用到了 /lib64/ld-linux-x86-64.so.2 运行库，目标是为了 GUN/Linux 3.2.0 版本而构建的，BuildID 为 a8c37790f6e986650f939fc4eea9383d527b23fd 等等的信息...

3. 看图片信息

![IMG_7413.jpg|100](assets/IMG_7413.jpg)
IMG_7413.jpg

```shell
$ file IMG_7413.JPG
IMG_7413.JPG: JPEG image data, JFIF standard 1.01, aspect ratio, density 72x72, segment length 16, Exif Standard: [TIFF image data, big-endian, direntries=5, xresolution=74, yresolution=82, resolutionunit=2], progressive, precision 8, 1585x1536, components 3
```

可以看到它说这个 `IMG_7413.jpg` 文件是 JPEG 图片数据，使用 JFIF 标准 1.01 版本，宽高比，密度 72x72，片段长度 16，EXIF 标准：[TIFF 图片数据，big-endian，direntries 5，xresolution 74，yresolution 82，resolutionunit 2]，渐进式，精度为 8，1585x1536 分辨率，组件 3

这其中有好多术语和标准需要额外查阅资料，这里不多赘述。

## cat 输出文件

**c**onc**a**tena**t**e，连环的含义，使用这个命令可以把任何文件的内容以文本形式输出到命令行上。
示例：

1. 看文本文件
hello 文件里面写着：世界你好！

```shell
$ cat hello
世界你好！
```

2. 看二进制文件

```shell
$ which curl
/usr/bin/curl

$ cat /usr/bin/curl
ELF>��@��@8
            @@@@h����D�D 0H0H#0H#�79 �y�y#�y#@��� ���DDS�td��� P�td@%@%@%��Q�tdR�td0H0H#0H#�7�7/lib64/ld-linux-x86-64.so.2GNU�GNUGNU��w���e����8=R{#�x�A �
x{(�BE���|fUa8��qX{�M���O�nH�hQ�* #�4"A��3�c�uC�Dt:����`��
                                                          t5����
# 以下省略
```

可以看到它强行把这个文件读取了，这个里面还有很多文件头的信息，这些信息在上一个命令 **file** 中被它读取并且解析，作为文件的元数据展示给你

3. 看图片文件

```shell
$ cat IMG_7413.JPG
����JFIFHH��)�ExifMMJR(�iZ�HH�0221��0100��1��
((�HH�����      																														��
���"���

}!1AQa"q2��#B��R��$3br�
%&'()*456789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz�������������������������������������������������������������������������
```

可以看到这个地方它也会强行把这个文件读取，不会自动转换为 base64 编码，这个里面也有很多文件头信息，被 **file** 命令读取并且使用

## mkdir 创建目录

**m**a**k**e new **dir**ectory ，制作新的目录的含义，使用这个命令可以创建目录，甚至多个目录
示例：

```shell
$ ls -la
总用量 4
drwxrwxr-x  2 neko neko    6 10月  9 17:14 .
drwxr-xr-x 16 neko neko 4096 10月  9 17:14 ..

$ mkdir test

$ ls -la
总用量 4
drwxrwxr-x  3 neko neko   18 10月  9 17:15 .
drwxr-xr-x 16 neko neko 4096 10月  9 17:15 ..
drwxrwxr-x  2 neko neko    6 10月  9 17:15 test # 多了一个 test 文件夹
```

### 一次创建多个层叠目录 - 参数 p

如果你想要在 `~/test` 目录中创建一个 `~/test/1/2/3` 的目录，但是其中的 目录 `1` 和 目录 `2` 都不存在的时候，直接输入 `mkdir ~/test/1/2/3` 是无法完成操作的：

```shell
$ mkdir test/1/2/3
mkdir: 无法创建目录 “test/1/2/3”: 没有那个文件或目录
```

此时我们需要添加**参数 `p`**，`p` 指的是 parent（父级）来自动创建中间缺失的父级目录：
示例：

```shell
$ mkdir -p test/1/2/3

$ tree # 使用 tree 命令可以可视化打印当前的目录结构（包含文件）
.
└── test
    └── 1
        └── 2
            └── 3

4 directories, 0 files
```

## touch 创建文件

touch，触摸的含义；类似于触摸一下，多了一个文件出来的感觉。使用这个命令可以创建一个空的文件，该文件没有任何编码、内容，只是存在于这个文件系统之中，占用「文件名」的大小

```shell
$ ls -la
总用量 4
drwxrwxr-x  2 neko neko    6 10月  9 17:21 .
drwxr-xr-x 16 neko neko 4096 10月  9 17:21 ..

$ touch hello

neko@ls-865528-12130-12130 ~/test
$ ls -la
总用量 4
drwxrwxr-x  2 neko neko   19 10月  9 17:21 .
drwxr-xr-x 16 neko neko 4096 10月  9 17:21 ..
-rw-rw-r--  1 neko neko    0 10月  9 17:21 hello # 多了一个 hello 文件
```

如果此时我们查看 hello 文件的信息、内容，会发现里面都是空的：

```shell
$ file hello
hello: empty

$ cat hello

```

## find 查找

find，查找的含义，这个命令用于查找文件和目录，使用方法很简单

```shell
find <搜索目录> -name <搜索对象>
```

示例：

我们要寻找一个叫做 `meow` 的文件，藏在 `tests` 文件夹下面

```shell
$ tree
.
├── hello
└── tests
    ├── meow
    └── test1
	
$ find ./ -name meow
./tests/meow
```

这样就能找到了，会返回相对位置

### 最大层级 - 参数 maxdepth

有时候目录的层级会很复杂，我们不希望递归搜索太久，可以限制搜索的层级数，需要添加**参数 `maxdepth`**，max depth（最大深度）的含义。`maxdepth` 接受数字类型的值。

示例：

我们要寻找一个叫做 `meow2` 的文件，藏在 `test1` 文件夹下面

```shell
$ tree
.
├── hello
└── tests
    ├── meow
    └── test1
        └── meow2
		
$ find ./ -name meow2 -maxdepth 2

$ find ./ -maxdepth 2 -name meow
./tests/meow

$ find ./ -maxdepth 3 -name meow2
./tests/test1/meow2
```

如果限制了只能最多两层的话，找不到 meow2，但是能找到 meow，限制了最多三层的话就能找到 meow2 了

**⚠️ 注意**：这个地方 `maxdepth` 参数必须放在最前面，要不然会报错。原因是 `maxdepth` 会影响到后面参数的匹配结果

### 搜索类型 - 参数 type

有时候不想搜索到目录，有时候不想搜索到文件，我们可以限制搜索的类型，需要添加**参数 `type`**， type（类型）的含义。`type` 参数接受两种字符串类型的值，分别是 **f**（file 文件）和 **d**（directory 目录）。

1. 限制文件 

```shell
$ tree
.
├── hello
└── tests
    ├── meow
    └── test1
        └── meow2
		
$ find ./ -name meow -type f
./tests/meow

$ find ./ -name meow -type d

```

限制为 `f` 的时候能搜索到 `meow` 文件，`d` 的时候就搜索不到了。

2. 限制目录

```shell
$ tree
.
├── hello
└── tests
    ├── meow
    └── test1
        └── meow2
		
$ find ./ -name test1 -type d
./tests/test1

$ $find ./ -name test1 -type f

```

限制为 `d` 的时候能搜索到 `test1` 目录，`f` 的时候就搜索不到了。

## mv 剪贴、移动

**m**o**v**e，移动的含义。使用这个命令可以把文件移动到别的地方，这个操作对于同一个分区、硬盘的文件而言十分快速，因为只需要改变在本文件系统中的路径地址即可，如果需要跨分区、甚至是跨硬盘设备的话，效率和复制文件一致。

```shell
mv <源路径> <目标路径>
```

示例：

1. 移动单个文件

```shell
$ mv meow meow2
```

2. 移动文件夹内文件到另一个文件夹

```shell
$ mv test/* test2/
```

### 其他参数

| 参数 | 说明 |
| ---- | ---- |
| **-b** | 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份 |
| **-i** | 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作 |
| **-f** | 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件 |
| **-n** | 不要覆盖任何已存在的文件或目录 |
| **-u** | 当源文件比目标文件新或者目标文件不存在时，才执行移动操作 |

## cp 复制

**c**o**p**y，复制的含义。使用这个命令可以把文件复制到别的地方，这个操作可能会很慢，因为需要把数据和路径一起变更，相比剪贴命令而言可能会慢很多，但是在同一个分区、硬盘内操作的话，依然是十分迅速的。

```shell
cp <源路径> <目标路径>
```

示例：

1. 复制单个文件

```shell
$ cp meow meow2
```

2. 移动文件夹内文件到另一个文件夹

```shell
$ cp test1/* test2/
```

### 复制时包含子文件夹中的文件 - 参数 r

```shell
$ cp -r test1/* test2/
```

### 其他参数

| 参数 | 说明 |
| ---- | ---- |
| **-a** | 此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合 |
| **-d** | 复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式 |
| **-f** | 覆盖已经存在的目标文件而不给出提示 |
| **-i** | 与 **-f** 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 y 时目标文件将被覆盖 |
| **-p** | 除复制文件的内容外，还把修改时间和访问权限也复制到新文件中 |
| **-r** | 若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件 |
| **-l** | 不复制文件，只是生成链接文件 |



## rm 移除文件

remove

## ps 进程列表

### 👷 施工中

## kill 进程终止

### 👷 施工中

## netstat 网络状态

### 👷 施工中

## top/htop/bpytop 任务管理器

### 👷 施工中

## systemd 服务管理

### 👷 施工中