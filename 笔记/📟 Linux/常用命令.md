## cd 变更目录

**c**hange **d**irectory（变更目录）的意思，使用这个命令可以变更当前 **工作目录** 的位置
示例：

```shell
$ pwd # pwd 可以获取当前工作目录地址
/home/neko

$ cd /etc

$ pwd
/etc # 可以看到这里发生了变更
```

**注意**：`cd` 命令是 shell 程序（诸如 bash、zsh）自己实现的功能，并不是一个实际的可执行程序

## ls 列出文件

**l**i**s**t（列表）的含义，使用这个命令可以看到当前 **工作目录** 下的文件
示例：

```shell
$ ls
aria2.sh  btop  ca.crt  go  source
```

### 展示隐藏文件 - 参数 a

通常目录中还会存在一些隐藏文件，比如以英文句点 `.` 开头的文件，这些文件默认是不会被 `ls` 列举出来的，需要添加 **参数 `a`**，`a` 指的是 all（全部）

示例：

```shell
$ ls -a
.   aria2.sh  .bash_logout  .viminfo  .yarn  .z .zshrc.pre-oh-my-zsh
```

### 列表形式打印 - 参数 l

横着打印的话并不是很方便去阅读和理解，我们可以把 `ls` 命令的结果使用列表的形式展示出来，需要添加**参数 `l`**，`l` 指的是 list（列表）

```shell
$ ls -l
总用量 36
-rwxrwxr-x 1 neko neko 29496 6月  15 15:37 aria2.sh
drwxrwxr-x 4 neko neko   188 9月  28 22:35 btop
-rw-r--r-- 1 root root  2163 8月  28 11:34 ca.crt
drwxrwxr-x 4 neko neko    28 7月  30 14:33 go
drwxrwxr-x 3 neko neko    23 9月  29 16:17 source
```

列表中有许多信息，这些信息可以通过下面的列表来一一对应查看：

| 权限 | 链接数 | 归属用户 | 归属用户组 | 大小 | 最后更新月份 | 最后更新日期 | 最后更新时间 | 名称 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | -- |
| -rwxrwxr-x | 1 | neko | neko | 29496 | 6月 | 15 | 15:37 | aria2.sh |
| drwxrwxr-x | 4 | neko | neko | 188  | 9月 | 28 | 22:35 | btop |
| -rw-r--r-- | 1 | root | root | 2163 | 8月 | 28 | 11:34 | ca.crt |
| drwxrwxr-x | 4 | neko | neko | 28 | 7月 | 30 | 14:33 | go |
| drwxrwxr-x | 3 | neko | neko | 23 | 9月 | 29 | 16:17 | source |

关于权限，可以参考：[[权限]]
其中：
1. **链接数** 指的是 Unix 文件系统中的 inode 链接数，这个值只对目录有效，指的是目录下面的 **项目数量**
2. **用户组** 在这个地方通常每个用户会对应有一个同名的组，这个组也有可能是别的组，比如 wheel（RHEL 系 Linux 系统的超级管理员组组名）
3. **最后更新时间** 是根据本机的时区来计算的，如果是通过 SSH 访问的机器，这个时间对应的是服务器的时间，并非是本地计算机的时间

## which/where 获取可执行命令对应的可执行文件

which（哪个），where（在哪里）的含义，使用这个命令可以获取到可执行命令的具体位置，这个命令包含以下集中形式：
1. shell 程序定义、内建的可执行命令，比如 cd
2. shell 脚本，可以被 shell 程序读取的代码文件，比如 hello_world.sh、hello_world.zsh 等等
3. 二进制可执行文件，编译好的程序，比如 curl、ls 等等

找不到命令和东西的时候可以先用这个试试看w

示例：
```shell
$ which cd # shell 内建命令
cd: shell built-in command # cd: shell 程序内建的命令

$ which hello_world.sh # sh 脚本文件
/usr/local/bin/hello_world.sh

$ which curl # 二进制可执行文件
/usr/bin/curl
```

## file 获取文件信息

file（文件）的含义，使用这个命令可以获取文件的信息、编码、格式、大小等等信息。
示例：

1. 看文本文件

hello 文件里面写着：hello, world!

```shell
$ file hello
hello: ASCII text
```

hello 文件里面写着：世界你好！

```shell
$ file hello
hello: UTF-8 Unicode text
```

2. 看二进制文件

```shell
$ which curl
/usr/bin/curl

$ file /usr/bin/curl
/usr/bin/curl: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=a8c37790f6e986650f939fc4eea9383d527b23fd, stripped
```

可以看到它说 curl 是一个 ELF 64 位 LSB 共享对象，对应平台 x86-64，版本 1（SYSV），通过动态链接库调用内部的运行库，调用到了 /lib64/ld-linux-x86-64.so.2 运行库，目标是为了 GUN/Linux 3.2.0 版本而构建的，BuildID 为 a8c37790f6e986650f939fc4eea9383d527b23fd 等等的信息...

3. 看图片信息

![IMG_7413.jpg|100](assets/IMG_7413.jpg)
IMG_7413.jpg

```shell
$ file IMG_7413.JPG
IMG_7413.JPG: JPEG image data, JFIF standard 1.01, aspect ratio, density 72x72, segment length 16, Exif Standard: [TIFF image data, big-endian, direntries=5, xresolution=74, yresolution=82, resolutionunit=2], progressive, precision 8, 1585x1536, components 3
```

可以看到它说这个 `IMG_7413.jpg` 文件是 JPEG 图片数据，使用 JFIF 标准 1.01 版本，宽高比，密度 72x72，片段长度 16，EXIF 标准：[TIFF 图片数据，big-endian，direntries 5，xresolution 74，yresolution 82，resolutionunit 2]，渐进式，精度为 8，1585x1536 分辨率，组件 3

这其中有好多术语和标准需要额外查阅资料，这里不多赘述。

## cat 输出文件

**c**onc**a**tena**t**e（连环）的含义，使用这个命令可以把任何文件的内容以文本形式输出到命令行上。
示例：

1. 看文本文件
hello 文件里面写着：世界你好！

```shell
$ cat hello
世界你好！
```

2. 看二进制文件

```shell
$ which curl
/usr/bin/curl

$ cat /usr/bin/curl
ELF>��@��@8
            @@@@h����D�D 0H0H#0H#�79 �y�y#�y#@��� ���DDS�td��� P�td@%@%@%��Q�tdR�td0H0H#0H#�7�7/lib64/ld-linux-x86-64.so.2GNU�GNUGNU��w���e����8=R{#�x�A �
x{(�BE���|fUa8��qX{�M���O�nH�hQ�* #�4"A��3�c�uC�Dt:����`��
                                                          t5����
# 以下省略
```

可以看到它强行把这个文件读取了，这个里面还有很多文件头的信息，这些信息在上一个命令 **file** 中被它读取并且解析，作为文件的元数据展示给你

3. 看图片文件

```shell
$ cat IMG_7413.JPG
����JFIFHH��)�ExifMMJR(�iZ�HH�0221��0100��1��
((�HH�����      																														��
���"���

}!1AQa"q2��#B��R��$3br�
%&'()*456789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz�������������������������������������������������������������������������
```

可以看到这个地方它也会强行把这个文件读取，不会自动转换为 base64 编码，这个里面也有很多文件头信息，被 **file** 命令读取并且使用

## mkdir 创建目录

**m**a**k**e new **dir**ectory （制作新的目录）的含义，使用这个命令可以创建目录，甚至多个目录
示例：

```shell
$ ls -la
总用量 4
drwxrwxr-x  2 neko neko    6 10月  9 17:14 .
drwxr-xr-x 16 neko neko 4096 10月  9 17:14 ..

$ mkdir test

$ ls -la
总用量 4
drwxrwxr-x  3 neko neko   18 10月  9 17:15 .
drwxr-xr-x 16 neko neko 4096 10月  9 17:15 ..
drwxrwxr-x  2 neko neko    6 10月  9 17:15 test # 多了一个 test 文件夹
```

### 一次创建多个层叠目录 - 参数 p

如果你想要在 `~/test` 目录中创建一个 `~/test/1/2/3` 的目录，但是其中的 目录 `1` 和 目录 `2` 都不存在的时候，直接输入 `mkdir ~/test/1/2/3` 是无法完成操作的：

```shell
$ mkdir test/1/2/3
mkdir: 无法创建目录 “test/1/2/3”: 没有那个文件或目录
```

此时我们需要添加**参数 `p`**，`p` 指的是 parent（父级）来自动创建中间缺失的父级目录：
示例：

```shell
$ mkdir -p test/1/2/3

$ tree # 使用 tree 命令可以可视化打印当前的目录结构（包含文件）
.
└── test
    └── 1
        └── 2
            └── 3

4 directories, 0 files
```

## touch 创建文件

touch（触摸），类似于触摸一下，多了一个文件出来的感觉。使用这个命令可以创建一个空的文件，该文件没有任何编码、内容，只是存在于这个文件系统之中，占用「文件名」的大小

```shell
$ ls -la
总用量 4
drwxrwxr-x  2 neko neko    6 10月  9 17:21 .
drwxr-xr-x 16 neko neko 4096 10月  9 17:21 ..

$ touch hello

neko@ls-865528-12130-12130 ~/test
$ ls -la
总用量 4
drwxrwxr-x  2 neko neko   19 10月  9 17:21 .
drwxr-xr-x 16 neko neko 4096 10月  9 17:21 ..
-rw-rw-r--  1 neko neko    0 10月  9 17:21 hello # 多了一个 hello 文件
```

如果此时我们查看 hello 文件的信息、内容，会发现里面都是空的：

```shell
$ file hello
hello: empty

$ cat hello

```

## find 查找

